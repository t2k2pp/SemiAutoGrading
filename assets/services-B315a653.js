const p="IPAGraderDB";const o={EXAMS:"exams",QUESTIONS:"questions",ANSWERS:"answers",GRADING_RESULTS:"gradingResults"},g={LLM_CONFIG:"ipa-grader-llm-config",UI_SETTINGS:"ipa-grader-ui-settings"};class f{db=null;async initDB(){return new Promise((e,t)=>{const n=indexedDB.open(p,1);n.onerror=()=>{t(new Error("IndexedDB初期化に失敗しました"))},n.onsuccess=()=>{this.db=n.result,e()},n.onupgradeneeded=a=>{const r=a.target.result;if(!r.objectStoreNames.contains(o.EXAMS)){const s=r.createObjectStore(o.EXAMS,{keyPath:"id"});s.createIndex("name","name",{unique:!1}),s.createIndex("createdAt","createdAt",{unique:!1})}if(!r.objectStoreNames.contains(o.QUESTIONS)){const s=r.createObjectStore(o.QUESTIONS,{keyPath:"id"});s.createIndex("examId","examId",{unique:!1}),s.createIndex("number","number",{unique:!1})}if(!r.objectStoreNames.contains(o.ANSWERS)){const s=r.createObjectStore(o.ANSWERS,{keyPath:"id"});s.createIndex("examId","examId",{unique:!1}),s.createIndex("studentId","studentId",{unique:!1}),s.createIndex("questionId","questionId",{unique:!1})}r.objectStoreNames.contains(o.GRADING_RESULTS)||r.createObjectStore(o.GRADING_RESULTS,{keyPath:"id"}).createIndex("answerId","answerId",{unique:!0})}})}async performDBOperation(e,t){if(!this.db)throw new Error("データベースが初期化されていません");return new Promise((n,a)=>{const s=this.db.transaction([e],"readwrite").objectStore(e),i=t(s);i.onsuccess=()=>n(i.result),i.onerror=()=>a(new Error(`データベース操作に失敗しました: ${i.error}`))})}async performDBReadOperation(e,t){if(!this.db)throw new Error("データベースが初期化されていません");return new Promise((n,a)=>{const s=this.db.transaction([e],"readonly").objectStore(e),i=t(s);i.onsuccess=()=>n(i.result),i.onerror=()=>a(new Error(`データベース読み取りに失敗しました: ${i.error}`))})}async saveExam(e){await this.performDBOperation(o.EXAMS,t=>t.put(e));for(const t of e.questions)await this.saveQuestion(t)}async getExam(e){const t=await this.performDBReadOperation(o.EXAMS,a=>a.get(e));if(!t)return null;const n=await this.getQuestionsByExamId(e);return{...t,questions:n}}async getAllExams(){const e=await this.performDBReadOperation(o.EXAMS,n=>n.getAll()),t=[];for(const n of e){const a=await this.getQuestionsByExamId(n.id);t.push({...n,questions:a})}return t}async deleteExam(e){await this.performDBOperation(o.EXAMS,a=>a.delete(e));const t=await this.getQuestionsByExamId(e);for(const a of t)await this.deleteQuestion(a.id);const n=await this.getAnswersByExamId(e);for(const a of n)await this.deleteAnswer(a.id)}async saveQuestion(e){await this.performDBOperation(o.QUESTIONS,t=>t.put(e))}async getQuestion(e){return await this.performDBReadOperation(o.QUESTIONS,t=>t.get(e))}async getQuestionsByExamId(e){return await this.performDBReadOperation(o.QUESTIONS,t=>t.index("examId").getAll(e))}async deleteQuestion(e){await this.performDBOperation(o.QUESTIONS,t=>t.delete(e))}async saveAnswer(e){await this.performDBOperation(o.ANSWERS,t=>t.put(e))}async getAnswer(e){return await this.performDBReadOperation(o.ANSWERS,t=>t.get(e))}async getAnswersByExamId(e){return await this.performDBReadOperation(o.ANSWERS,t=>t.index("examId").getAll(e))}async getAnswersByStudentId(e){return await this.performDBReadOperation(o.ANSWERS,t=>t.index("studentId").getAll(e))}async deleteAnswer(e){await this.performDBOperation(o.ANSWERS,n=>n.delete(e));const t=await this.getGradingResultByAnswerId(e);t&&await this.deleteGradingResult(t.id)}async saveGradingResult(e){await this.performDBOperation(o.GRADING_RESULTS,t=>t.put(e))}async getGradingResult(e){return await this.performDBReadOperation(o.GRADING_RESULTS,t=>t.get(e))}async getGradingResultByAnswerId(e){return await this.performDBReadOperation(o.GRADING_RESULTS,t=>t.index("answerId").get(e))}async getAllGradingResults(){return await this.performDBReadOperation(o.GRADING_RESULTS,e=>e.getAll())}async deleteGradingResult(e){await this.performDBOperation(o.GRADING_RESULTS,t=>t.delete(e))}saveLLMConfig(e){localStorage.setItem(g.LLM_CONFIG,JSON.stringify(e))}getLLMConfig(){const e=localStorage.getItem(g.LLM_CONFIG);return e?JSON.parse(e):null}saveUISettings(e){localStorage.setItem(g.UI_SETTINGS,JSON.stringify(e))}getUISettings(){const e=localStorage.getItem(g.UI_SETTINGS);return e?JSON.parse(e):null}async clearAllData(){if(!this.db)return;const e=[o.EXAMS,o.QUESTIONS,o.ANSWERS,o.GRADING_RESULTS];for(const t of e)await this.performDBOperation(t,n=>n.clear())}clearLocalStorage(){Object.values(g).forEach(e=>{localStorage.removeItem(e)})}isConnected(){return this.db!==null}close(){this.db&&(this.db.close(),this.db=null)}}const w=new f;class S{config;constructor(e){this.config=e}updateConfig(e){this.config=e}async testConnection(){try{return(await fetch(`${this.config.endpoint}/models`,{method:"GET",headers:{"Content-Type":"application/json"},signal:AbortSignal.timeout(this.config.timeout)})).ok}catch(e){return console.error("LM Studio接続テストに失敗:",e),!1}}async getAvailableModels(){try{const e=await fetch(`${this.config.endpoint}/models`,{method:"GET",headers:{"Content-Type":"application/json"},signal:AbortSignal.timeout(this.config.timeout)});if(!e.ok)throw new Error(`HTTP ${e.status}: ${e.statusText}`);return(await e.json()).data?.map(n=>n.id)||[]}catch(e){throw console.error("モデル一覧取得に失敗:",e),new Error("モデル一覧の取得に失敗しました")}}generateGradingPrompt(e,t){const n=`You are a grader for the IPA Project Manager certification exam.
Grade the answer according to the following criteria and return the result in JSON format.

Grading criteria:
- ○: Equivalent to the sample answer (meets 80% or more elements)
- △: Partially correct (meets 50-79% of elements)
- ×: Incorrect or off-topic (less than 50%)

Return the output in the following JSON format:
{
  "score": "○" | "△" | "×",
  "points": numeric_score,
  "reason": "grading_reason_within_100_chars"
}`,a=`QUESTION:
${e.content}

QUESTION INTENT:
${e.intention}

SAMPLE ANSWER:
${e.sampleAnswer}

MAX SCORE: ${e.maxScore} points`,r=`STUDENT ANSWER TO GRADE:
Student ID: ${t.studentId}
Answer Content: ${t.content}`;return{systemPrompt:n,questionContext:a,answerToGrade:r,gradingCriteria:`GRADING CRITERIA:
- Does the answer accurately understand the question requirements?
- Does the answer align with the question intent?
- How much does the answer include elements from the sample answer?
- Are appropriate PM knowledge and expressions used?
- Is the content logical and consistent?`}}async gradeAnswer(e,t){const n=this.generateGradingPrompt(e,t),a=`${n.questionContext}

${n.answerToGrade}

${n.gradingCriteria}

Please grade the student answer based on the above information and return the result in JSON format.`;try{let r="",s={"Content-Type":"application/json"},i={model:this.config.model,messages:[{role:"system",content:n.systemPrompt},{role:"user",content:a}],temperature:this.config.temperature};switch(this.config.useMaxTokens&&(i.max_tokens=this.config.maxTokens),this.config.provider){case"lm-studio":r=`${this.config.endpoint}/chat/completions`,s.Authorization="Bearer dummy-key";break;case"ollama":r=`${this.config.ollamaHost||this.config.endpoint}/v1/chat/completions`;break;case"azure-openai":this.config.apiVersion?.includes("v1")?r=`${this.config.endpoint}/openai/v1/chat/completions`:r=`${this.config.endpoint}/openai/deployments/${this.config.deploymentId}/chat/completions?api-version=${this.config.apiVersion}`,this.config.apiKey&&(s["api-key"]=this.config.apiKey);break;case"gemini":r=`${this.config.endpoint}/models/${this.config.model}:generateContent`,this.config.geminiApiKey&&(s["x-goog-api-key"]=this.config.geminiApiKey);const u={temperature:this.config.temperature};this.config.useMaxTokens&&(u.maxOutputTokens=this.config.maxTokens),i={contents:[{parts:[{text:`${n.systemPrompt}

${a}`}]}],generationConfig:u};break;default:throw new Error(`Unsupported provider: ${this.config.provider}`)}console.log("Making request to:",r),console.log("Request body:",JSON.stringify(i,null,2));const d=await fetch(r,{method:"POST",headers:s,body:JSON.stringify(i),signal:AbortSignal.timeout(this.config.timeout)});if(!d.ok)throw new Error(`HTTP ${d.status}: ${d.statusText}`);const h=await d.json();let c="";switch(this.config.provider){case"lm-studio":case"ollama":case"azure-openai":c=h.choices?.[0]?.message?.content;break;case"gemini":c=h.candidates?.[0]?.content?.parts?.[0]?.text;break}if(!c)throw new Error("LLMからの応答が空です");console.log("LLM Response:",c);let l;try{const u=c.match(/```json\s*([\s\S]*?)\s*```/);u?l=JSON.parse(u[1]):l=JSON.parse(c)}catch{l=this.extractGradingFromText(c)}return this.validateGradingResponse(l,e.maxScore),l}catch(r){throw console.error("LLM採点に失敗:",r),r instanceof Error?r.name==="AbortError"?new Error("採点がタイムアウトしました"):new Error(`採点処理でエラーが発生しました: ${r.message}`):new Error("採点処理で不明なエラーが発生しました")}}extractGradingFromText(e){console.log("Extracting from text:",e);const t=[/["']?score["']?\s*:\s*["']([○△×])["']/,/score\s*:\s*([○△×])/,/([○△×])/,/grade\s*:\s*([○△×])/],n=[/["']?points?["']?\s*:\s*(\d+)/,/points?\s*:\s*(\d+)/,/(\d+)\s*points?/,/score:\s*(\d+)/],a=[/["']?reason["']?\s*:\s*["']([^"']+)["']/,/reason\s*:\s*(.+?)(?:\n|$)/,/because\s*:\s*(.+?)(?:\n|$)/,/explanation\s*:\s*(.+?)(?:\n|$)/];let r=null;for(const d of t)if(r=e.match(d),r)break;let s=null;for(const d of n)if(s=e.match(d),s)break;let i=null;for(const d of a)if(i=e.match(d),i)break;if(!r)throw console.error("No score found in text:",e),new Error("採点結果のスコアを抽出できませんでした");return{score:r[1],points:s?parseInt(s[1],10):5,reason:i?i[1].trim():"採点理由を抽出できませんでした"}}validateGradingResponse(e,t){if(!["○","△","×"].includes(e.score))throw new Error(`無効なスコア: ${e.score}`);if(typeof e.points!="number"||e.points<0||e.points>t)throw new Error(`無効な点数: ${e.points} (最大: ${t})`);if(!e.reason||typeof e.reason!="string"||e.reason.length===0)throw new Error("採点理由が無効です");const n=e.points/t*100;e.score==="○"&&n<80?console.warn(`スコア○だが点数が低い: ${e.points}/${t} (${n.toFixed(1)}%)`):e.score==="△"&&(n<50||n>=80)?console.warn(`スコア△だが点数が範囲外: ${e.points}/${t} (${n.toFixed(1)}%)`):e.score==="×"&&n>=50&&console.warn(`スコア×だが点数が高い: ${e.points}/${t} (${n.toFixed(1)}%)`)}async gradeBatch(e,t,n){throw new Error("バッチ採点機能は現在開発中です")}async checkConsistency(e,t,n=3){const a=[];for(let c=0;c<n;c++){const l=await this.gradeAnswer(e,t);a.push(l),c<n-1&&await new Promise(u=>setTimeout(u,500))}const r=a.map(c=>c.points),s=r.reduce((c,l)=>c+l,0)/r.length,i=r.reduce((c,l)=>c+Math.pow(l-s,2),0)/r.length,h=Math.sqrt(i)<=e.maxScore*.1;return{results:a,isConsistent:h,variance:i}}}const E=new S({provider:"lm-studio",endpoint:"http://127.0.0.1:1234/v1",model:"gemma-3n-e4b-it-text",temperature:.1,maxTokens:500,useMaxTokens:!0,timeout:12e4});export{w as d,E as l};
//# sourceMappingURL=services-B315a653.js.map
